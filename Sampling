module uart_rx
  #(parameter CLKS_PER_BIT)

  (

   input        clk,

   input        data_in,

   output       data_Ready,

   output [7:0] data,

   );

    

 // parameter s_IDLE         = 3'b000;

  //parameter s_RX_START_BIT = 3'b001;

  //parameter s_RX_DATA_BITS = 3'b010;

 // parameter s_RX_STOP_BIT  = 3'b011;

 // parameter s_CLEANUP      = 3'b100;

  reg clk_1;

  assign clk_1 <= clk;
 
  reg           data_temp = 1'b1;

  reg           data_1   = 1'b1;// use in sampling bit

  reg           s1=3'b000;// idle
  
  reg           s2=3'b001;// 
  
  reg           s3=3'b010;//
  
  reg           s4=3'b011;//
  
  reg           s5=3'b100;// clean up
  
  reg [7:0]     cycle_count = 0;// 128(1BT),192(1.5BT)

  reg [2:0]     bit_count   = 0; //8 bits total

  reg [7:0]     temp_data_byte     = 0;// store data  temporarily

  reg           control_bit     = 0;// control state

  reg [2:0]     state_count     = 0;// state count

   

  // Purpose: Double-register the incoming data.

  // This allows it to be used in the UART RX Clock Domain.

  // (It removes problems caused by metastability)

  always @(posedge clk_1)

    begin

      data_temp <= data_in;

      data_1   <= data_temp;

    end

  // Purpose: Control RX state machine

  always @(posedge clk_1)

    begin

       

      case (state_count)

        s_IDLE :

          begin

            control_bit <= 1'b0;

            cycle_count <= 0;

            bit_count   <= 0;

            if (data_1 == 1'b0)          // Start bit detected

              state_count <= s2;

            else

              state_count <= s1;

          end

         

        // Check middle of start bit to make sure it's still low

        s_RX_START_BIT :

          begin

            if (cycle_count == 192)

              begin

                if (data_1 == 1'b0)

                  begin

                    cycle_count <= 0;  // reset counter, found the middle

                    state_count <= s3;

                  end

                else

                  state_count <= s1;

              end

            else

              begin

                cycle_count <= cycle_count + 1;

                state_count <= s2;

              end

          end // case: s_RX_START_BIT

         

         

        // Wait CLKS_PER_BIT-1 clock cycles to sample serial data

        s_RX_DATA_BITS :

          begin

            if (cycle_count == 128 )

              begin
              
                cycle_count  <= 0;

                temp_data_byte[bit_count] <= data_1;


              end

            else

              begin
 
                cycle_count <= cycle_count + 1;

                state_count     <= s3;

                // Check if we have received all bits

                if (bit_count < 7)

                  begin

                    bit_count <= bit_count + 1;

                    state_count   <= s3;

                  end

                else

                  begin

                    bit_count <= 0;

                    state_count   <= s4;

                  end

              end

          end // case: s_RX_DATA_BITS

     

     

        // Receive Stop bit.  Stop bit = 1

        s_RX_STOP_BIT :

          begin

            // Wait CLKS_PER_BIT-1 clock cycles for Stop bit to finish
/*
            if (cycle_count < CLKS_PER_BIT-1)

              begin

                cycle_count <= cycle_count + 1;

                state_count     <= s4;

              end
*/
            if( bit_count == 7)

              begin

                control_bit       <= 1'b1;

                cycle_count <= 0;

                state_count     <= s5;

              end

          end // case: s_RX_STOP_BIT

     

         

        // Stay here 1 clock

        s_CLEANUP :

          begin

            state_count <= s1;

            control_bit   <= 1'b0;

          end



        default :

          state_count <= s1;

         

      endcase

    end   

   

  assign data_Ready   = control_bit;

  assign data = temp_data_byte;

   

endmodule // uart_rx
